"""
Module contains base class definitions for candidate mesophase management.

Declarations here allow PSO algorithm objects to uniformly access mesophase
data and simulations from any given SCFT simulator by abstracting specifics
of the simulator formatting from the interface through class hierarchies.
"""

from abc import ABC, abstractmethod
from copy import deepcopy
import os
import io

class MesophaseBase(ABC):
    """ 
    Abstract base class for mesophase wrapper classes.
    Derived classes manage a single mesophase for a single SCFT simulator.
    """
    AvailableVariables = [ "BlockLengths"
    
    
    @abstractmethod
    def update(self, root, **kwargs):
        """
            Launch a simulation of the mesophase and parse results.
            
            Parameters
            ----------
            root : str, filepath
                The absolute path to the root directory of the simulation.
                Any files generated by the simulation will be placed here.
            
            Returns
            -------
            flag : int
                0 if simulation converged without issue. -1 if an error occurred.
        """
        pass
    
    @abstractmethod
    def setParams(self, **kwparams):
        """
            Update the value of the (universally formatted)
            keyworded parameters. 
            Formats for common variables specified here. Up to derived class to
            Relate given formats to underlying data.
            
            Available Parameters:
            'BlockLength(_chainID#_)(_block#_)' : Block lengths (or fractions)
            'chi(_monomer1#_)(#monomer2#)' : chiN values
            'DegreePolymerizationN(#chainID#)' : Polymer Degree of polymerization (total)
            'StatisticalSegLength(#monomerID#)' : Statistical Segment length of monomer
        """
        pass
        
    @abstractmethod
    @property
    def energy(self):
        """
            The energy of the mesophase as of the most recent simulation.
            
            Returns
            -------
            E : real or np.NaN
                If the simulation failed to converge, returns np.NaN.
                Else returns the simulated energy.
        """
        pass
    

class MesophaseManager(object):
    """
        Manages a set of Mesophase objects based on universal set of 
        variable parameters. Responsible for coordinating launch, parsing,
        and comparison of multiple mesophase simulations
        
        *** should be SCFT-Simulator-Independent ***
    """
    
    def __init__(self, candidates, target, variables, **kwargs):
        """
            Initialize the MesophaseManager.
            
            Parameters
            ----------
            candidates : dict
                Keys are name of phase.
                Values are MesophaseBase-like objects.
                The set of initialized candidate phases.
                All should be capable of launching simulations
                as-is.
            target : string
                The key of the "candidate" that should be considered
                the "target" phase - the one being sought
            variables : dict
                Parameters being varied for all of the candidate
                phases. Should match up with formats specified in
                MesophaseBase.setParams. All candidates should
                contain a corresponding parameter.
        """
        self.candidates = deepcopy(candidates)
        if self.candidates.get(target,None) is not None:
            self.target = target
        else:
            raise(ValueError(str(target)+"is not in the list of candidates"))
        self.variables = deepcopy(variables)
    
    def setParams(self, **kwargs):
        """ Update Parameters in each mesophase """
        
        for (k,v) in self.variables.items():
            if kwargs.get(k,None) is not None:
                self.variables.update(k,v)
            else:
                raise(ValueError("No value given for variable "+k))
    
    def calculatePhases(self, root, **kwargs):
        """ Launch simulations with current variable values """
        # Currently runs all jobs in sequence
        # TODO: Revise to allow parallellization
        for (name,c) in self.candidates.items():
            c.setParams(**self.variables)
            candidRoot = os.path.join(root, name)
            c.update(candidRoot)
    
    @property
    def fitness(self):
        """ Calculate and return the fitness of the mesophase set """
        tgt = self.candidates.get(self.target)
        tgtE = tgt.energy
        fit = None
        for (k,c) in self.candidates.items():
            test = c.energy - tgtE
            if not c == tgt:
                if fit is not None:
                    if fit < test:
                        fit = test
                else:
                    fit = test
        return fit
            
        
    def update(self, root):
        """ Launch Simulations and return fitness """
        self.calculatePhases(root)
        return self.fitness
